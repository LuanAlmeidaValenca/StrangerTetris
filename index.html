<!DOCTYPE html>
<html>
<head>
  <title>STRANGER TETRIS</title>
  <meta charset="UTF-8">
  <style>
  @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
  *{
    font-family: 'Press Start 2P', cursive;
    background-color: rgb(0, 0, 0);
  }
  .TETRIS {
  text-align: center;
}
  html, body {   

    height: 100%;
    margin: 0;
  }
    h1{
        text-align: center;
        color: white;
    }
    h6{
        text-align: center;
        color: white;
    }
    h4{
        text-align: right;
        color: white;
    }

  canvas{ 
    border: 1px solid black;
    margin: 10px auto;
    background-color: white;
}
    .pontuacao {
        color: white;
        font-size: 20px;
        text-align: center;
        position: flex;
        top: 10px;
        right: 10px;
    }
  </style>
</head>
<body>
  <div id="TETRIS" class="TETRIS">
    <h1>WELCOME TO THE STRANGER TETRIS</h1>
    <h6 >PRESS F5 TO RESTART</h6>
    <div class="pontuacao" id="pontuacao">Pontos: 0</div>
    <canvas width="250" height="500" id="TelaUm" class="TelaUm"></canvas>
    <script>
            //Declaração de uma variavel global para somar os Pontos dos dois jogos
            let pontosTotais = 0;
            let rAF = null;
            let rAF2 = null;
            let count = 0;
//Utilização de matrizes para definir o formato das peças, com letras para identificar de forma intuitiva a formação das peças 
            const PecasTetris = {
          'I': [
              [0, 0, 0, 0],
              [1, 1, 1, 1],
              [0, 0, 0, 0],
              [0, 0, 0, 0]
          ],
          'J': [
              [1, 0, 0],
              [1, 1, 1],
              [0, 0, 0],
          ],
          'L': [
              [0, 0, 1],
              [1, 1, 1],
              [0, 0, 0],
          ],
          'O': [
              [1, 1],
              [1, 1],
          ],
          'S': [
              [0, 1, 1],
              [1, 1, 0],
              [0, 0, 0],
          ],
          'Z': [
              [1, 1, 0],
              [0, 1, 1],
              [0, 0, 0],
          ],
          'T': [
              [0, 1, 0],
              [1, 1, 1],
              [0, 0, 0],
          ]
      };
//constante que usa a nomeação das peças para definir cores especificas para elas
      const CoresTetris = {
          'I': 'cyan',
          'O': 'yellow',
          'T': 'purple',
          'S': 'green',
          'Z': 'red',
          'J': 'blue',
          'L': 'orange'
      };

     
    </script>
    <script>
      // Função para gerar números inteiros aleatórios 
      const gerarNumeroAleatorio = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
  
      // Função que gera uma sequência aleatória das peças, 
      const GeradorDeAleatoriedade = () => {
          const sequencia = ['I', 'J', 'L', 'O', 'S', 'T', 'Z']; //Peças ja criadas e existentes
  
          return sequencia
              .map((a) => ({ sort: Math.random(), value: a }))
              .sort((a, b) => a.sort - b.sort)
              .map((a) => a.value);
      };
      
      /* Função para obter a próxima peça da sequência, Ele recebe a proxima peça de acordo com o GeradorDeAleatoriedade
      caso a matriz SequenciaTetris esteja vazia, ela chama a função GeradorDeAleatoriedade para criar uma sequencia 
      aleatoria de peças que são colocadas na matriz atravéz do push */
      const ProximaPecaDeTetris = () => {
          if (SequenciaTetris.length === 0) {
              SequenciaTetris.push(...GeradorDeAleatoriedade());
          }
  
          const name = SequenciaTetris.pop();
          const matrix = PecasTetris[name];
          const col = FrameDoJogo[0].length / 2 - Math.ceil(matrix[0].length / 2);
          const row = name === 'I' ? -1 : -2;
  
          return {
              name,
              matrix,
              row,
              col
          };
      };
  
     
  
      // Função para verificar se um movimento é válido, verificando se a posição almejada nao esta ocupada por uma peça ou barreira
      const isValidMove = (matrix, cellRow, cellCol) =>  //matrix é a peça que sera verificada, cellrow a linha que sera verificada e cellcol a Coluna que sera verificada
          matrix.every((row, rowIndex) =>           
              row.every((val, colIndex) =>
                  !val || (
                      cellCol + colIndex >= 0 &&
                      cellCol + colIndex < FrameDoJogo[0].length &&
                      cellRow + rowIndex < FrameDoJogo.length &&
                      !FrameDoJogo[cellRow + rowIndex][cellCol + colIndex]
                  )
              )
          );
  
      /* Função para colocar a peça de tetris no campo de jogo, ela faz isso inicialmente a partir de uma verificação da possibilidade
       do jogo ter ou não sido finalizado, pelo primeiro "if" que analisa se os limites do jogo já foram ultrapassados, caso contrario
       é inserida uma peça na posição inicial da tela */
      const InjetarPecaTetris = () => {
          tetromino.matrix.map((row, rowIndex) => {
              row.map((val, colIndex) => {
                  if (val) {
                      if (tetromino.row + rowIndex < 0) {
                          return showGameOver();
                      }
  
                      FrameDoJogo[tetromino.row + rowIndex][tetromino.col + colIndex] = tetromino.name;
                  }
              });
          });
          // Variável para contar quantas linhas já foram quebradas, a medida que esse numero aumenta, é alterada  
          // a pontuação do jogador
          let ColunasCheias = 0;
        
          /* Analisa se as linhas estão completas, esse procedimento é feito checando o valor de todos os elementos da linha, 
          caso todos sejam diferente de 0, significa que ela está completa. Depois disso, FrameDoJogo.splice e FrameDoJogo.unshift
          removem a linha e adicionam outra acima respectivamente*/
          FrameDoJogo.filter((row, rowIndex) => {
              if (row.every(cell => !!cell)) {
                  FrameDoJogo.splice(rowIndex, 1);
                  FrameDoJogo.unshift(Array(10).fill(0));
                  ColunasCheias++;
              }
          });
  
          if (ColunasCheias > 0) {
              atualizarPontos(ColunasCheias);
          }
  
          tetromino = ProximaPecaDeTetris();
      };
  
      
  
      const canvas = document.getElementById('TelaUm');
      const context = canvas.getContext('2d');
      const grid = 25;
      const SequenciaTetris = [];
  
      const FrameDoJogo = Array.from({ length: 20 }, () => Array(10).fill(0));
      let tetromino = ProximaPecaDeTetris();
      let gameOver = false;
  
      const loop = () => {
          rAF = requestAnimationFrame(loop);
          context.clearRect(0, 0, canvas.width, canvas.height);
  
          FrameDoJogo.map((row, rowIndex) => {
              row.map((cell, colIndex) => {
                  if (cell) {
                      context.fillStyle = CoresTetris[cell];
                      context.fillRect(colIndex * grid, rowIndex * grid, grid - 1, grid - 1);
                  }
              });
          });
  
          if (tetromino) {
              if (++count > 30) {
                  tetromino.row++;
                  count = 0;
  
                  if (!isValidMove(tetromino.matrix, tetromino.row, tetromino.col)) {
                      tetromino.row--;
                      InjetarPecaTetris();
                  }
              }
  
              context.fillStyle = CoresTetris[tetromino.name];
  
              tetromino.matrix.map((row, rowIndex) => {
                  row.map((val, colIndex) => {
                      if (val) {
                          context.fillRect(
                              (tetromino.col + colIndex) * grid,
                              (tetromino.row + rowIndex) * grid,
                              grid - 1,
                              grid - 1
                          );
                      }
                  });
              });
          }
          
      };
        // Função para rotacionar uma matriz no sentido anti-horário
        const rotate = matrix => matrix[0].map((_, i) => matrix.map(row => row[i])).reverse();
  
      //função para movimentação das peças do Tetris, Ela recebe uma verificação passando pelo Validador de Movimento (isValidMove2)
      const moverParaEsquerdas = (tetromino, FrameDoJogo, isValidMove) => {
          const newCol = tetromino.col - 1;
          if(isValidMove(tetromino.matrix, tetromino.row, newCol, FrameDoJogo)) {
            return {...tetromino, col: newCol}
          }
          return tetromino;
        };
        const moverParaDireitas = (tetromino, FrameDoJogo, isValidMove) => {
          const newCol = tetromino.col + 1;
          if(isValidMove(tetromino.matrix, tetromino.row, newCol, FrameDoJogo)) {
            return {...tetromino, col: newCol}
          }
          return tetromino;
        };

        const moverParaRotacaos = (tetromino, FrameDoJogo, isValidMove, rotate) => {
          const rotatedMatrix = rotate(tetromino.matrix);
          if(isValidMove(rotatedMatrix, tetromino.col, tetromino.row, FrameDoJogo)) {
            return {...tetromino, matrix: rotatedMatrix}
          }
          return tetromino;
        };

        const moverParaCimas = (tetromino, FrameDoJogo, isValidMove) => {
          const newRow = tetromino.row + 1;
          if(isValidMove(tetromino.matrix, newRow, tetromino.col, FrameDoJogo)) {
            return {...tetromino, row: newRow}
          }
          return tetromino;
        };

          document.addEventListener('keydown', (e) => {
            if (gameOver) return;

            switch (e.which) {
              case 65: // Tecla A (esquerda)
                tetromino = moverParaEsquerdas(tetromino, FrameDoJogo, isValidMove);
                break;
              case 68: // Tecla D (direita)
                tetromino = moverParaDireitas(tetromino, FrameDoJogo, isValidMove);
                break;
              case 87: // Tecla W (girar anti-horário)
                tetromino = moverParaRotacaos(tetromino, FrameDoJogo, isValidMove, rotate);
                break;
              case 83: // Tecla S (mover para cima)
                tetromino = moverParaCimas(tetromino, FrameDoJogo, isValidMove);
                break;
              default:
                // Outra tecla pressionada, não faz nada
                break;
            }
          });
  
      rAF = requestAnimationFrame(loop);

      let pontos1 = 0;
      const atualizarPontos = (linhas) => {
      const pontosPorLinha = [0, 100, 300, 500, 800];
      pontos1 += pontosPorLinha[linhas];
      atualizarPontosTotal();
};
        // Função para exibir a tela de game over
        const showGameOver = () => {
                  cancelAnimationFrame(rAF);
                  gameOver = true;
          
                  context.fillStyle = 'black';
                  context.globalAlpha = 0.75;
                  context.fillRect(0, canvas.height / 2 - 30, canvas.width, 60);
          
                  context.globalAlpha = 1;
                  context.fillStyle = 'white';
                  context.font = '36px monospace';
                  context.textAlign = 'center';
                  context.textBaseline = 'middle';
                  context.fillText('GAME OVER!', canvas.width / 2, canvas.height / 2);
        };
            
      </script>
      <canvas width="250" height="500" id="TelaDois"></canvas>
      <script>
        // Função de utilidade para gerar números inteiros aleatórios
        const getRandomInt2 = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
      
        // Função para gerar a sequência aleatória das peças
        const generateSequence2 = () => {
          const sequence = ['I', 'J', 'L', 'O', 'S', 'T', 'Z'];
          const shuffledSequence = [...sequence];
      
          for (let i = shuffledSequence.length - 1; i > 0; i--) {
            const j = getRandomInt2(0, i);
            [shuffledSequence[i], shuffledSequence[j]] = [shuffledSequence[j], shuffledSequence[i]];
          }
      
          return shuffledSequence;
        };
      
        // Esta função obtém a próxima peça da sequência de peças de Tetris.
        // Ela verifica se a sequência de peças está vazia e, se estiver, gera uma nova sequência
        // Em seguida, ela retira o primeiro elemento da sequência
        // e obtém a matriz e o nome da peça correspondente. O col e o row determinam a posição inicial
        // da peça no campo de jogo.
        const getNextTetromino2 = () => {
          if (tetrominoSequence.length === 0) {
            tetrominoSequence.push(...generateSequence2());
          }
        playfield2
          const name = tetrominoSequence.pop();
          const matrix = PecasTetris[name];
          const col = Math.floor(playfield2[0].length / 2) - Math.ceil(matrix[0].length / 2);
          const row = 20 - matrix.length; // Alterado para 20 menos a altura da peça
      
          return {
            name,
            matrix,
            row,
            col
          };
        };
      
        // Esta função realiza a rotação de uma matriz no sentido anti-horário.
        // Ela recebe uma matriz como entrada e retorna uma nova matriz que é a rotação
        // da matriz de entrada.
        const rotateAntiClockwise2 = matrix => matrix[0].map((_, i) => matrix.map(row => row[i])).reverse();
      
        // Esta função verifica se um movimento é válido para a peça de Tetris representada pela matriz 'matrix',
        // quando tentamos movê-la para a posição 'cellRow' e 'cellCol' no campo de jogo.
        // Ela utiliza a função 'every' para percorrer cada célula da matriz do tetromino, verificando se:
        // 1. A célula não contém um valor verdadeiro (se estiver vazia, o movimento é válido);
        // 2. A posição 'cellCol' + 'colIndex' está dentro dos limites horizontais do campo de jogo;
        // 3. A posição 'cellRow' + 'rowIndex' está dentro dos limites verticais do campo de jogo;
        // 4. A célula correspondente no campo de jogo 'playfield2' também está vazia.
        // Se todas essas condições forem atendidas para cada célula da matriz do tetromino, o movimento é considerado válido
        const isValidMove2 = (matrix, cellRow, cellCol) =>
          matrix.every((row, rowIndex) =>
            row.every((val, colIndex) =>
              !val || (
                cellCol + colIndex >= 0 &&
                cellCol + colIndex < playfield2[0].length &&
                cellRow + rowIndex >= 0 &&
                cellRow + rowIndex < playfield2.length &&
                !playfield2[cellRow + rowIndex][cellCol + colIndex]
              )
            )
          );
      
        // função que coloca a peça de Tetris atual
        // no campo de jogo. Ela itera sobre os elementos da matriz do tetromino
        // e os posiciona no campo de jogo, levando em consideração a posição atual do tetromino
        // Se a posição estiver dentro dos limites do campo
        // de jogo, o valor correspondente ao nome do tetromino é atribuído à célula
        // correspondente no campo de jogo.
        const placeTetromino2 = () => {
          tetromino2.matrix.map((row, rowIndex) => {
            row.map((val, colIndex) => {
              if (val) {
                const playfieldRow = tetromino2.row + rowIndex;
                const playfieldCol = tetromino2.col + colIndex;
      
                if (playfieldRow >= 0) {
                  playfield2[playfieldRow][playfieldCol] = tetromino2.name;
                }
              }
            });
          });
      
          let linesToRemove = [];
      
          //  função que verifica se há linhas completas no campo de jogo .
          // Ele percorre o campo de baixo para cima e, para cada linha,
          // verifica se todas as células da linha contêm valores verdadeiros (diferentes de 0).
          // Se uma linha estiver completa, é removido.
          for (let row = playfield2.length - 1; row >= 0; row--) {
            if (playfield2[row].every(cell => !!cell)) {
              linesToRemove.push(row);
            }
          }
      
          // função que remove as linhas completas do campo de jogo,
          // começando pelas linhas mais baixas.
          linesToRemove.filter(row => {
            playfield2.splice(row, 1);
          });
          atualizarPontos2(linesToRemove.length);
      
          // função que adiciona novas linhas vazias no topo do campo de jogo 
          // para compensar as linhas que foram removidas anteriormente.
          for (let i = 0; i < linesToRemove.length; i++) {
            playfield2.unshift(Array(10).fill(0));
          }
      
          // função responsável por realizar as seguintes ações:
          // 1. Decrementar a posição da linha do tetromino em um valor igual à quantidade de linhas a serem removidas,
          // fazendo com que as linhas abaixo subam.
          // 2. Obter o próximo tetromino da sequência usando a função 'getNextTetromino2'.
          // 3. Verificar se o novo tetromino é colocado em uma posição válida no campo de jogo usando a função 'isValidMove2'.
          // 4. Se o novo tetromino não puder ser colocado em uma posição válida, exibe a tela de "GAME OVER" usando a função 'showGameOver2'.
          tetromino2.row -= linesToRemove.length;
      
          tetromino2 = getNextTetromino2();
      
          if (!isValidMove2(tetromino2.matrix, tetromino2.row, tetromino2.col)) {
            showGameOver2();
          }
        };
      
        // função que exibe a tela de "GAME OVER" na tela 2 do jogo Tetris quando o jogo termina.
        // Ela cancela o loop de animação, define a variável 'gameOver2' como verdadeira, preenche
        // a tela com um fundo preto semi-transparente e exibe o texto "GAME OVER" no centro da tela.
          const showGameOver2 = () => {
          cancelAnimationFrame(rAF2);
          gameOver2 = true;
      
          context2.fillStyle = 'black';
          context2.globalAlpha = 0.75;
          context2.fillRect(0, 0, canvas2.width, canvas2.height);
      
          context2.globalAlpha = 1;
          context2.fillStyle = 'white';
          context2.font = '36px monospace';
          context2.textAlign = 'center';
          context2.textBaseline = 'middle';
          context2.fillText('GAME OVER!', canvas2.width / 2, canvas2.height / 2);
        };
      
        const canvas2 = document.getElementById('TelaDois');
        const context2 = canvas2.getContext('2d');
        const grid2 = 25;
        const tetrominoSequence = [];
      
        const playfield2 = Array.from({ length: 20 }, () => Array(10).fill(0));
        let tetromino2 = getNextTetromino2();
        let gameOver2 = false;
        //função para gerar o Loop de iniciação do jogo
        // Ela utiliza o requestAnimationFrame para chamar a si mesma repetidamente e
        // atualiza a tela 2, limpando o contexto de renderização, desenhando o campo de jogo,
        // manipulando a queda do tetromino e verificando colisões. Também lida com a
        // renderização gráfica do tetromino atual na tela 2.
        const loopTelaDois = () => {
          rAF2 = requestAnimationFrame(loopTelaDois);
          context2.clearRect(0, 0, canvas2.width, canvas2.height);
      
          playfield2.map((row, rowIndex) => {
            row.map((cell, colIndex) => {
              if (cell) {
                context2.fillStyle = CoresTetris[cell];
                context2.fillRect(colIndex * grid2, rowIndex * grid2, grid2, grid2);
              }
            });
          });
      
          if (tetromino2) {
            if (++count > 30) {
              const newRow = tetromino2.row - 1;
              count = 0;
      
              if (isValidMove2(tetromino2.matrix, newRow, tetromino2.col)) {
                tetromino2.row = newRow;
              } else {
                placeTetromino2();
              }
            }
      
            context2.fillStyle = CoresTetris[tetromino2.name];
      
            tetromino2.matrix.map((row, rowIndex) => {
              row.map((val, colIndex) => {
                if (val) {
                  context2.fillRect(
                    (tetromino2.col + colIndex) * grid2,
                    (tetromino2.row + rowIndex) * grid2,
                    grid2,
                    grid2
                  );
                }
              });
            });
          }
          
        };
      //função para movimentação das peças do Tetris, Ela recebe uma verificação passando pelo Validador de Movimento (isValidMove2)
        const moverParaEsquerda = (tetromino2, playfield2, isValidMove2) => {
          const newCol = tetromino2.col - 1;
          if(isValidMove2(tetromino2.matrix, tetromino2.row, newCol, playfield2)) {
            return {...tetromino2, col: newCol}
          }
          return tetromino2;
        };
        const moverParaDireita = (tetromino2, playfield2, isValidMove2) => {
          const newCol = tetromino2.col + 1;
          if(isValidMove2(tetromino2.matrix, tetromino2.row, newCol, playfield2)) {
            return {...tetromino2, col: newCol}
          }
          return tetromino2;
        };

        const moverParaRotacao = (tetromino2, playfield2, isValidMove2, rotateAntiClockwise2) => {
          const rotatedMatrix = rotateAntiClockwise2(tetromino2.matrix);
          if(isValidMove2(rotatedMatrix, tetromino2.col, tetromino2.row, playfield2)) {
            return {...tetromino2, matrix: rotatedMatrix}
          }
          return tetromino2;
        };

        const moverParaCima = (tetromino2, playfield2, isValidMove2) => {
          const newRow = tetromino2.row - 1;
          if(isValidMove2(tetromino2.matrix, newRow, tetromino2.col, playfield2)) {
            return {...tetromino2, row: newRow}
          }
          return tetromino2;
        };
          
          document.addEventListener('keydown', (e) => {
            if (gameOver2) return;
            //Controles da tela invertida
            switch (e.which) {
              case 74: // Tecla J (esquerda)
                tetromino2 = moverParaEsquerda(tetromino2, playfield2, isValidMove2);
                break;
              case 76: // Tecla L (direita)
                tetromino2 = moverParaDireita(tetromino2, playfield2, isValidMove2);
                break;
              case 73: // Tecla I (girar anti-horário)
                tetromino2 = moverParaRotacao(tetromino2, playfield2, isValidMove2, rotateAntiClockwise2);
                break;
              case 75: // Tecla K (mover para cima)
                tetromino2 = moverParaCima(tetromino2, playfield2, isValidMove2);
                break;
              default:
                // Outra tecla pressionada, não faz nada
                break;
            }
          });


        let pontos2 = 0; //variavel para contar os pontos da Tela2
        
        // Esta função calcula a pontuação da tela 2 com base na quantidade de linhas quebradas.
        // Em seguida, chama a função 'atualizarPontosTotal' para atualizar a pontuação total
        // exibida na página, que inclui as pontuações de ambas as telas.
        const atualizarPontos2 = (linhas) => {
          const pontosPorLinha = [0, 100, 300, 500, 800];
          pontos2 += pontosPorLinha[linhas];
          atualizarPontosTotal();
        };
        //faz o requerimento para começar o loop(necessita que o loppTelaDois exista)
        rAF2 = requestAnimationFrame(loopTelaDois);
      </script>
      <script>
        // Esta função atualiza um elemento HTML na página para exibir a
        // pontuação total, que é calculada somando as pontuações das duas
        // telas do jogo diferentes.
        const atualizarPontosTotal = () => {
          const pontuacaoTotal = pontos1 + pontos2;
          const elementoPontuacao = document.getElementById('pontuacao');
          elementoPontuacao.textContent = `Pontuação Total: ${pontuacaoTotal}`;
        }   

        atualizarPontosTotal();
        
      </script>    
  </div>

</body>
</html>
